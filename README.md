## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2401`

#### Выполнил: `Москвитин Марк Александрович`

#### Вариант: `16`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Выбор структуры данных](#2-выбор-структуры-данных)
- [Алгоритм](#3-алгоритм)
- [Программа](#4-программа)
- [Анализ правильности решения](#5-анализ-правильности-решения)

### 1. Постановка задачи

Программа управляет заказами ресторана, выполняя следующие действия:

1. Создаёт ресторан с заданным максимальным количеством одновременно обраба- тываемых заказов.
2. Добавляет заказ в список активных заказов. Указывается название блюда и ко- личество этапов готовки. Если список заказов полон, новый заказ не добавляется.
3. Отображает список активных заказов от самого старого к самому новому. Для каждого заказа указывается, сколько этапов готовки осталось выполнить.
4. Выполняет один этап готовки для заказа с указанным номером (номер отсчиты- вается от самого старого заказа). Если этапов не осталось, заказ удаляется из списка.
5. Выполняет n этапов готовки для заказа с указанным номером. Если количество этапов меньше n, оставшиеся действия игнорируются.
6. Выполняет n этапов, начиная с первого заказа. Если первый заказ завершён, оставшиеся действия применяются к следующему заказу и так далее, пока не закончатся действия или заказы.
7. Выполняет по одному действию для каждого заказа из переданного массива но- меров. Номера заказов не изменяются, даже если какие-то заказы завершаются.
8. Отображает список всех завершённых заказов в порядке их выполнения.
9. Удаляет заказ по указанному номеру, где номер отсчитывается с конца списка выполненных заказов.

Для ее успешной работы мы должны:
- Создать класс для объекта ресторан, подготовить значения максимального количества заказов, общего количества заказов, количества выполненных заказов и нынешнее количество заказов.
- Создать класс для выполнения различный функций изменения данных о заказе или его удаления c хранением информации в массивах.

### 2. Выбор структуры данных

Нам придется работать с целыми и натуральными числами, поэтому для их хранения воспользуемся переменными типа integer. Кроме этого, мы будем сохранять списки заказов, то есть нас интересует и тип String.Получается, нам потребуется и соответствующий тип массивов. За хранение количества этапов готовки также будет отвечать integer[].

|                |    Тип (в Java)    |  min значение   |  max значение  |  Название переменной  |
|----------------|--------------------|-----------------|----------------|-----------------------|
| Макс_значение  |      Integer       |        0        |   2147483647   |     max_orders        |
| Общее_кол-во   |      Integer       |        0        |   2147483647   |     cnt_orders        |
| Нынешнее_кол-во|      Integer       |        0        |   2147483647   |     now_orders        |
| Кол-во законч. |      Integer       |        0        |   2147483647   |     end_orders        |
|    Заказы      |      String[]      |       []        |       -        |       orders          |
| Кол-во эт. зак.|      Integer[]     |       []        |       -        |       orders_et       |
|    Уд. Заказы  |      String[]      |       []        |       -        |       del_orders      |


### 3. Алгоритм

**Class Restaraunt**:
1. Cоздает объект с полями максимального количества заказов, нынешнего количества заказа, законченных заказов, общего количества и объектом класса Order;
2. Предупреждает пользователя о максимальном количестве заказов в настоящий момент в ресторане;
3. Регулирует создание строчек для вывода информации о заказах и о законченных заказах;
4. Регулирует процессы изменения данных о заказе: запускает выполнение действий в этапах готовки с помошью класса Order, а также передает информацию о необходимости отмены определенного заказа;
5. Позволяет увеличить количество максимальных заказов;
6. Выводит системные сообщения об ошибке в случае проверок на дурака.
7. Необходим для удобной работы с функциями для каждого из ресторанов.

**Class Order**:
1. Хранит массивы в качестве полей с информацией о заказах, этапах готовки и выполненных заказов.
2. Создает эти массивы.
3. Добавляет заказ и его количество этапов готовки в соответсвующие массивы.
4. Позволяет благодаря геттерам получить классу Restaraunt значение своих полей;
5. Проверяет на дурака функции выполнения этапов готовки;
6. Содержит функцию выполнения этапа готовки, которая используется во всез задачах, связанных с этапами готовки.
7. Оформляет отмену заказа;
8. Добавляет заказы в списки выполненных, когда они выполняются.
9. Позволяет отделить лишнюю информацию от класса ресторана и хранить ее отдельно для оптимизации и более удобной работы алгоритма, что делать его необходимым для использования.

### 4. Классы

```java
class Restaraunt
  {
    
      private int max_orders = 0; //поле для ограничений максимального кол-ва заказов ресторана
      private int cnt_orders = 0; //общее количество заказов, которое когда-нибудь давали ресторану
      private int now_orders = 0; //количество заказов, которые прямо сейчас находятся в обработке
      private int end_orders = 0; //количество заказов, которые были отменены или выполнены
      private Orders list; // объект класса Заказ
      public Restaraunt(int max_orders) { //конструктор Ресторана
        if (max_orders > 0) {     // проверка на дурака для кол-ва заказов
          this.max_orders = max_orders;
          this.list = new Orders(max_orders);
        }
        else {
          error_amount();  // не проход проверки
          this.max_orders = max_orders;
          this.list = new Orders(0);
        }  
      }
      public Restaraunt() { //запасной конструктор для дураков
        this.max_orders = 0;
        awarenumbr();
        this.list = new Orders(0);
      }
      public void NewOrder(String P, int K) { //новый заказ с названием блюда и количеством этапов готовки
        if(now_orders < max_orders) { //проверка на максимум заказов в ресторане
          cnt_orders++; //доавление в общее и нынешнее количество
          now_orders++;
          this.list.AddOrder(P,K, now_orders-1); //добавление заказа
        }
        else  {
          limit(); //ошибка о невозможности принять заказ из-за максимальной загруженности
        }
      }

     public void ListOrders() { //вывод на экран действующих заказов
         String[] orders1 = list.getOrders();   //геттер заказов
         int[] orders1_et = list.getOrders_et(); //геттер этапов готовки
         for( int i = 0; i < now_orders; i++) {
          System.out.println("Заказ: " + orders1[i] + " | Этапов готовки: " + orders1_et[i]); //просто выводим
         }
     }
     public void OneOrder(int numb) {      //одно действие по заказу
          if(list.OneOrd(numb,end_orders,now_orders)){ //выполняем дейсивие и проверяем, нужно ли что-то удалять. если да - изменяем количество; 
            end_orders++;
            now_orders--;
          }
     }
     public void ManyOrder(int numb,int n){ //несколько действий по одному заказу 
      for(int j = 1;j <= n; j++) {
        if(list.OneOrd(numb,end_orders,now_orders)){ //выполняем дейсивие и проверяем, нужно ли что-то удалять. если да - изменяем количество; 
          end_orders++;
          now_orders--;
          break; // если заказ уже выполнен, повторять действия не надо
        }
      }
     }

     public void ManyOrders(int n){ // много действий по разным заказам
      int numb = 1+ end_orders;
      for(int j = 1;j <= n; j++) {
        if(list.OneOrd(numb,end_orders,now_orders)){ //выполняем дейсивие и проверяем, нужно ли что-то удалять. если да - изменяем количество; 
          end_orders++;
          now_orders--;
          numb++;
        }
      }
     }

     public void ManyOrdersList(int[] n){ //по одному действию на массив номеров
      int numb = 0;
      for(int j = 0;j < n.length; j++) {
        if(list.OneOrd(n[j],end_orders,now_orders)){ //выполняем действие и проверяем, нужно ли что-то удалять. если да - изменяем количество; 
          end_orders++;
          now_orders--;
        }
      }
     }

     public void ListEndOrders() { //перечислить все заказы, которые завершились
      String[] del_orders1 = list.getDelOrders(); //геттер такого списка
      for( int i = 0; i < del_orders1.length; i++) {
        System.out.println("Заказ: " + del_orders1[i] ); //вывод
       }

     }

     public void CancelOrder(int numb) { //отмена заказа по номеру среди нынешних
              list.EndOrder(numb); //функция
              end_orders++; 
              now_orders--; //изменяем параметры
     }
      
      private void awarenumbr() { //для проверки на дурака
        System.out.println("Введите максимальное количество заказов в вашем ресторана, используя функцию UpdateMaxOrders() или заново инициализируйте ресторан");
      }
      private void limit() { //макс. кол-во заказов
        System.out.println("В настоящий момент в ресторане обрабатывается максимальное количество заказ. Подождите, пожалуйста, когда один из них будет выполнен");
      }
      private void error_amount() { //для проверки на дурака
        System.out.println("Вы ввели некорректное максимальное количество заказов в вашем ресторана, заново инициализируйте ресторан");
      }
  
  }
``` 

``` java




class Orders {
    private String[] orders = new String[0]; // поле - список заказов
    private int[] orders_et = new int[0]; // поле - список этапов готовки
    private String[] del_orders = new String[0]; // поле - список выполненных заказов
    public Orders(int max_orders) {  //конструктор, который создает списки с ограничением по максимальному кол-ву заказов в ресторане
        this.orders = new String[max_orders];
        this.orders_et = new int[max_orders];
    }
    public void AddOrder(String P, int K,int now_orders) { //добавление заказа на свободную позицию в список
        orders[now_orders] = P;
        orders_et[now_orders] = K;
    }
    public String[] getOrders() { //геттер списка заказов
        return orders;
    }
    public int[] getOrders_et() { //геттер списка этапов готовки
        return orders_et;
    }
    public String[] getDelOrders() { //геттер списка выполненных заказов
        return del_orders;
    }
    public boolean OneOrd(int numb,int end,int now) { //функция для выполнения действия, возвращая информацию, был ли удален заказ из-за полного выполнения
        if(numb - 1 - end   < 0 || numb - 1 - end  > now) { //проверка на дурака при вводе номера, невозможного для обработки
             error_limit();
             return false;
        }
        else {
            orders_et[numb - 1 - end] =  orders_et[numb - 1 - end]-1 ;//минус один этап
        if(orders_et[numb - 1 - end] == 0) { //удаление в случае достижения нуля в значении количества этапов
            DeleteAdd(orders[numb - 1 - end]); //добавление в список выполненных
            for(int i = numb - 1 - end;i < orders_et.length-1;i++) { //перенос списков
                orders_et[i] = orders_et[i+1];
                orders[i] = orders[i+1];
                
            }
            return true;
        }
        else {
            return false;
        }
        }
        
    }



   public void EndOrder(int numb) { //удаление заказа при его отмене
    for(int i = numb - 1;i < orders_et.length-1;i++) {
        orders_et[i] = orders_et[i+1];
        orders[i] = orders[i+1];
    }

   }

    private void DeleteAdd(String P) {    //функция для обновления массива выполненных заказов
       String[] del_orders1 = new String[del_orders.length+1];
       for (int i = 0; i <del_orders.length; i++) {
        del_orders1[i] = del_orders[i];
       }
       del_orders1[del_orders.length] = P;
       del_orders = del_orders1.clone(); 
    }

    private void error_limit() {    //системное сообщение для не прохода проверки на дуракак
         System.out.print("Невозможно выполнить действие, данный заказ был отменен или выполнен");
    }

    
    
}

``` 

### 5. Анализ правильности решения
Программа работает корректно при подстановке всевозможных различных значений и проверки функций.
1. Максимальное количество заказов
    - **Code**:
        ```java
         Restaraunt restik = new Restaraunt(5);
         restik.NewOrder("Макароны",2);
         restik.NewOrder("Греча",4);
         restik.NewOrder("Рис",3);
         restik.NewOrder("Картошка",4);
         restik.NewOrder("Арбуз",5);
         restik.NewOrder("Дыня",4);  //вылезает ошибка, ибо мы пытаемся добавить 6 заказ
         restik.ListOrders();            //список всех заказов
         out.println();
        ```
    - **Output**:
        ```
        В настоящий момент в ресторане обрабатывается максимальное количество заказ. Подождите, пожалуйста, когда один из них будет выполнен
        Заказ: Макароны | Этапов готовки: 2
        Заказ: Греча | Этапов готовки: 4
        Заказ: Рис | Этапов готовки: 3
        Заказ: Картошка | Этапов готовки: 4
        Заказ: Арбуз | Этапов готовки: 5
        ```
2. Выполняем три действия в третьем заказе, чтобы он был выполнен. Проверяем наличие в списке выполненных заказов и отсуствие в списке действующих.
    - **Code**:
        ```java
         restik.ManyOrder(3, 3);  //закрываем 3 заказ выполнением всех трех действий
         restik.ListEndOrders();         //проверяем список выполненных
         out.println();
         restik.ListOrders();            //проверяем общий список нынешних
         out.println();
        ```
    - **Output**:
        ```
            Заказ: Рис

            Заказ: Макароны | Этапов готовки: 2
            Заказ: Греча | Этапов готовки: 4
            Заказ: Картошка | Этапов готовки: 4
            Заказ: Арбуз | Этапов готовки: 5
        ```
3. Проверяем, работает ли нумерация от общего количества заказов, а не текущего списка.
    - **Code**:
        ```java
         restik.OneOrder(4);       //проверяем, работает ли нумерация
         restik.ListOrders();           //проверяем общий список нынешних
         out.println();
        ```
    - **Output**:
        ```    
        Заказ: Макароны | Этапов готовки: 2
        Заказ: Греча | Этапов готовки: 4
        Заказ: Картошка | Этапов готовки: 3
        Заказ: Арбуз | Этапов готовки: 5
        ```
4. Проверяем функцию отмены заказа, которая отменяет заказ по нынешнему номеру и не добавляет его в список выполненных.
    - **Code**:
        ```java
         restik.CancelOrder(3);     //проверяем, работает ли отмена заказа
         restik.ListOrders();            //проверяем общий список нынешних
         out.println();
        ```
    - **Output**:
        ```    
            Заказ: Макароны | Этапов готовки: 2
            Заказ: Греча | Этапов готовки: 4
            Заказ: Арбуз | Этапов готовки: 5
        ```
5. Проверяем, добавляется ли заказ в конец.
    - **Code**:
        ```java
         restik.NewOrder("Дыня",4);  //смотрим, добавится ли заказ в конец
         restik.ListOrders();            //список всех заказов
         out.println();
        ```
    - **Output**:
        ```    
            Заказ: Макароны | Этапов готовки: 2
            Заказ: Греча | Этапов готовки: 4
            Заказ: Арбуз | Этапов готовки: 5
            Заказ: Дыня | Этапов готовки: 4
        ```
6. Смотрим массовое применение действий.
    - **Code**:
        ```java
         restik.ManyOrders(7);     //проверяем, работает ли массовое применение по очереди
         restik.ListOrders();            //проверяем общий список нынешних
         out.println();
         restik.ListEndOrders();         //проверяем список выполненных
         out.println();
        ```
    - **Output**:
        ```    
            Заказ: Арбуз | Этапов готовки: 4
            Заказ: Дыня | Этапов готовки: 4

            Заказ: Рис
            Заказ: Макароны
            Заказ: Греча
        ```
7. Сразу обрабатываем новый заказ.
    - **Code**:
        ```java
         restik.NewOrder("Кускус",4);
         restik.ManyOrder(7, 3);  //обрабатываем последний заказ
         restik.ListOrders();            //проверяем общий список нынешних
         out.println();
        ```
    - **Output**:
        ```    
            Заказ: Арбуз | Этапов готовки: 4
            Заказ: Дыня | Этапов готовки: 4
            Заказ: Кускус | Этапов готовки: 1
        ```
8. Применяем по одному действию к массиву номеров.
    - **Code**:
        ```java
         int[] a = new int[2];
         a[0] = 6;
         a[1] = 7;
         restik.ManyOrdersList(a);       //проверяем одно действие по массиву
         restik.ListOrders();            //проверяем общий список нынешних
         out.println();
        ```
    - **Output**:
        ```    
            Заказ: Арбуз | Этапов готовки: 4
            Заказ: Дыня | Этапов готовки: 3
        ```
9. Проверка на номера, связанная с номерами заказов.
    - **Code**:
        ```java
         restik.OneOrder(3);  //вывод ошибки
        ```
    - **Output**:
        ```    
            Невозможно выполнить действие, данный заказ был отменен или выполнен
        ```





  

